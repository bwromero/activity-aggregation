# Angular Patterns & Best Practices Reference

A comprehensive guide to modern Angular patterns for state management, API calls, and component architecture.

---

## üìö Table of Contents

1. [State Management Patterns](#state-management-patterns)
2. [Service Patterns](#service-patterns)
3. [Component Patterns](#component-patterns)
4. [HTTP & API Patterns](#http--api-patterns)
5. [Caching Patterns](#caching-patterns)
6. [Error Handling Patterns](#error-handling-patterns)
7. [Loading State Patterns](#loading-state-patterns)

---

## üéØ State Management Patterns

### Pattern 1: Signal-Based State (Zoneless - Modern)

**Use Case:** Managing reactive state in zoneless Angular applications

**Pattern Name:** Signal State Management

```typescript
// Service
@Injectable({ providedIn: 'root' })
export class UserService {
  // Private writable signals
  private readonly _user = signal<User | null>(null);
  private readonly _loading = signal(false);
  private readonly _error = signal<string | null>(null);

  // Public readonly signals
  readonly user = this._user.asReadonly();
  readonly loading = this._loading.asReadonly();
  readonly error = this._error.asReadonly();

  // Computed signals
  readonly isAuthenticated = computed(() => this._user() !== null);
  readonly userName = computed(() => this._user()?.name ?? 'Guest');

  loadUser(id: number): void {
    this._loading.set(true);
    this._error.set(null);

    this.http.get<User>(`/api/users/${id}`).pipe(
      tap(user => {
        this._user.set(user);
        this._loading.set(false);
      }),
      catchError(err => {
        this._error.set('Failed to load user');
        this._loading.set(false);
        return of(null);
      })
    ).subscribe();
  }
}

// Component (Zoneless)
@Component({
  selector: 'app-user-profile',
  template: `
    @if (userService.loading()) {
      <mat-spinner></mat-spinner>
    } @else if (userService.error()) {
      <div class="error">{{ userService.error() }}</div>
    } @else {
      <div>{{ userService.userName() }}</div>
    }
  `
})
export class UserProfileComponent {
  protected readonly userService = inject(UserService);
}
```

**Pros:**
- ‚úÖ No Zone.js overhead
- ‚úÖ Synchronous, predictable updates
- ‚úÖ Type-safe computed values
- ‚úÖ Better performance

---

### Pattern 2: Observable State with BehaviorSubject (Zone.js)

**Use Case:** Managing reactive state with RxJS observables

**Pattern Name:** Observable State Pattern

```typescript
// Service
@Injectable({ providedIn: 'root' })
export class UserService {
  // Private subjects
  private readonly _user$ = new BehaviorSubject<User | null>(null);
  private readonly _loading$ = new BehaviorSubject<boolean>(false);
  private readonly _error$ = new BehaviorSubject<string | null>(null);

  // Public observables
  readonly user$ = this._user$.asObservable();
  readonly loading$ = this._loading$.asObservable();
  readonly error$ = this._error$.asObservable();

  // Computed/derived streams
  readonly isAuthenticated$ = this.user$.pipe(
    map(user => user !== null)
  );

  readonly userName$ = this.user$.pipe(
    map(user => user?.name ?? 'Guest')
  );

  loadUser(id: number): void {
    this._loading$.next(true);
    this._error$.next(null);

    this.http.get<User>(`/api/users/${id}`).pipe(
      tap(user => {
        this._user$.next(user);
        this._loading$.next(false);
      }),
      catchError(err => {
        this._error$.next('Failed to load user');
        this._loading$.next(false);
        return of(null);
      })
    ).subscribe();
  }
}

// Component (with Zone.js)
@Component({
  selector: 'app-user-profile',
  template: `
    @if (loading$ | async) {
      <mat-spinner></mat-spinner>
    } @else if (error$ | async; as error) {
      <div class="error">{{ error }}</div>
    } @else {
      <div>{{ userName$ | async }}</div>
    }
  `
})
export class UserProfileComponent {
  protected readonly userService = inject(UserService);
  protected readonly loading$ = this.userService.loading$;
  protected readonly error$ = this.userService.error$;
  protected readonly userName$ = this.userService.userName$;
}
```

**Pros:**
- ‚úÖ Mature, well-established pattern
- ‚úÖ Powerful RxJS operators
- ‚úÖ Automatic subscription management with async pipe

---

## üîß Service Patterns

### Pattern 3: Repository Pattern (API Client)

**Use Case:** Separating API calls from business logic

**Pattern Name:** Repository/API Client Pattern

```typescript
// API Client (Repository)
@Injectable({ providedIn: 'root' })
export class ActivityApiClient {
  private readonly http = inject(HttpClient);
  private readonly baseUrl = `${environment.apiBaseUrl}/api/activities`;

  getAggregated(groupBy: string[], page: number, size: number): Observable<PagedResponse> {
    const params = new HttpParams()
      .appendAll({ groupBy })
      .append('page', page)
      .append('size', size);

    return this.http.get<PagedResponse>(`${this.baseUrl}/aggregate`, { params });
  }

  getById(id: number): Observable<Activity> {
    return this.http.get<Activity>(`${this.baseUrl}/${id}`);
  }

  create(activity: CreateActivityDto): Observable<Activity> {
    return this.http.post<Activity>(this.baseUrl, activity);
  }
}

// Service (Business Logic)
@Injectable({ providedIn: 'root' })
export class ActivityService {
  private readonly apiClient = inject(ActivityApiClient);
  private readonly cache = inject(CacheService);

  private readonly _data = signal<Activity[]>([]);
  readonly data = this._data.asReadonly();

  loadData(groupBy: string[]): void {
    const cacheKey = groupBy.sort().join(',');
    const cached = this.cache.get(cacheKey);
    
    if (cached) {
      this._data.set(cached);
      return;
    }

    this.apiClient.getAggregated(groupBy, 0, 25).pipe(
      tap(response => {
        this._data.set(response.content);
        this.cache.set(cacheKey, response.content);
      })
    ).subscribe();
  }
}
```

**Benefits:**
- ‚úÖ Single Responsibility Principle
- ‚úÖ Easier to test
- ‚úÖ Reusable API client
- ‚úÖ Centralized HTTP logic

---

### Pattern 4: Facade Pattern (Simplifying Complex Services)

**Use Case:** When a service exposes many related functionalities

**Pattern Name:** Facade Pattern

```typescript
// Without Facade (Complex)
@Component({})
export class DashboardComponent {
  private readonly userService = inject(UserService);
  private readonly settingsService = inject(SettingsService);
  private readonly notificationService = inject(NotificationService);

  ngOnInit() {
    this.userService.loadCurrentUser();
    this.settingsService.loadSettings();
    this.notificationService.subscribe();
  }
}

// With Facade (Simplified)
@Injectable({ providedIn: 'root' })
export class DashboardFacade {
  private readonly userService = inject(UserService);
  private readonly settingsService = inject(SettingsService);
  private readonly notificationService = inject(NotificationService);

  // Exposed state
  readonly user = this.userService.user;
  readonly settings = this.settingsService.settings;
  readonly notifications = this.notificationService.notifications;

  // Simplified initialization
  initialize(): void {
    this.userService.loadCurrentUser();
    this.settingsService.loadSettings();
    this.notificationService.subscribe();
  }
}

@Component({})
export class DashboardComponent {
  protected readonly facade = inject(DashboardFacade);

  ngOnInit() {
    this.facade.initialize();
  }
}
```

---

## üß© Component Patterns

### Pattern 5: Smart/Dumb Components (Container/Presentational)

**Use Case:** Separating logic from presentation

**Pattern Name:** Container-Presentational Pattern

```typescript
// Smart Component (Container) - Handles logic
@Component({
  selector: 'app-activity-container',
  template: `
    <app-activity-filter
      [isProjectSelected]="service.isProjectSelected()"
      [isEmployeeSelected]="service.isEmployeeSelected()"
      (fieldToggled)="service.toggleField($event)"
    />
    
    <app-activity-table
      [data]="service.data()"
      [loading]="service.loading()"
      [columns]="service.displayedColumns()"
    />
  `
})
export class ActivityContainerComponent {
  protected readonly service = inject(ActivityService);
}

// Dumb Component (Presentational) - Only displays data
@Component({
  selector: 'app-activity-filter',
  template: `
    <mat-checkbox 
      [checked]="isProjectSelected()"
      (change)="fieldToggled.emit('project')"
    >
      Project
    </mat-checkbox>
  `
})
export class ActivityFilterComponent {
  // Input signals
  isProjectSelected = input.required<boolean>();
  isEmployeeSelected = input.required<boolean>();

  // Output signal
  fieldToggled = output<string>();
}
```

**Benefits:**
- ‚úÖ Reusable presentation components
- ‚úÖ Easier to test presentational logic
- ‚úÖ Clear separation of concerns

---

### Pattern 6: Signal Inputs/Outputs (Modern Angular)

**Use Case:** Component communication in Angular 17+

**Pattern Name:** Signal-Based Component API

```typescript
// Parent Component
@Component({
  selector: 'app-parent',
  template: `
    <app-child
      [title]="title()"
      [count]="count()"
      (itemClicked)="handleClick($event)"
    />
  `
})
export class ParentComponent {
  title = signal('Hello');
  count = signal(0);

  handleClick(item: string): void {
    console.log('Clicked:', item);
  }
}

// Child Component (Signal Inputs/Outputs)
@Component({
  selector: 'app-child',
  template: `
    <h2>{{ title() }}</h2>
    <p>Count: {{ count() }}</p>
    <button (click)="onClick()">Click Me</button>
  `
})
export class ChildComponent {
  // Signal inputs
  title = input.required<string>();
  count = input<number>(0);

  // Signal outputs
  itemClicked = output<string>();

  onClick(): void {
    this.itemClicked.emit('item-1');
  }
}
```

---

### Pattern 7: ViewChild Signal (Accessing Child Components)

**Use Case:** Accessing child component/element references

**Pattern Name:** ViewChild Signal Pattern

```typescript
@Component({
  selector: 'app-paginator-container',
  template: `
    <mat-paginator
      [length]="totalElements()"
      [pageSize]="pageSize()"
      (page)="onPageChange($event)"
    />
  `
})
export class PaginatorContainerComponent {
  // Signal-based ViewChild
  paginator = viewChild.required(MatPaginator);

  ngAfterViewInit() {
    // Access paginator methods
    const paginatorInstance = this.paginator();
    paginatorInstance.firstPage();
  }
}
```

---

## üåê HTTP & API Patterns

### Pattern 8: Debounced API Calls (Signals + RxJS)

**Use Case:** Reducing API calls for rapid user input

**Pattern Name:** Debounce Pattern with Signals

```typescript
@Injectable({ providedIn: 'root' })
export class SearchService {
  private readonly http = inject(HttpClient);
  private readonly searchTrigger$ = new Subject<string>();

  private readonly _results = signal<SearchResult[]>([]);
  private readonly _loading = signal(false);

  readonly results = this._results.asReadonly();
  readonly loading = this._loading.asReadonly();

  constructor() {
    // Set up debounced search
    this.searchTrigger$.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      tap(() => this._loading.set(true)),
      switchMap(query => 
        this.http.get<SearchResult[]>(`/api/search?q=${query}`).pipe(
          catchError(() => of([]))
        )
      ),
      tap(results => {
        this._results.set(results);
        this._loading.set(false);
      })
    ).subscribe();
  }

  search(query: string): void {
    this.searchTrigger$.next(query);
  }
}

// Component
@Component({
  template: `
    <input 
      type="text" 
      (input)="searchService.search($event.target.value)"
    />
    @if (searchService.loading()) {
      <mat-spinner></mat-spinner>
    }
    @for (result of searchService.results(); track result.id) {
      <div>{{ result.name }}</div>
    }
  `
})
export class SearchComponent {
  protected readonly searchService = inject(SearchService);
}
```

---

### Pattern 9: Retry Logic with Exponential Backoff

**Use Case:** Handling transient API failures

**Pattern Name:** Retry with Backoff Pattern

```typescript
@Injectable({ providedIn: 'root' })
export class ResilientApiService {
  private readonly http = inject(HttpClient);

  getData(): Observable<Data> {
    return this.http.get<Data>('/api/data').pipe(
      retry({
        count: 3,
        delay: (error, retryCount) => {
          // Exponential backoff: 1s, 2s, 4s
          const delayMs = Math.pow(2, retryCount) * 1000;
          console.log(`Retry ${retryCount} after ${delayMs}ms`);
          return timer(delayMs);
        }
      }),
      catchError(error => {
        console.error('All retries failed', error);
        return throwError(() => new Error('Failed after retries'));
      })
    );
  }
}
```

---

## üíæ Caching Patterns

### Pattern 10: Time-Based Cache (Map-Based)

**Use Case:** Caching API responses with expiration

**Pattern Name:** TTL Cache Pattern

```typescript
interface CacheEntry<T> {
  data: T;
  timestamp: number;
}

@Injectable({ providedIn: 'root' })
export class TimeBasedCache {
  private readonly cache = new Map<string, CacheEntry<any>>();
  private readonly TTL = 5 * 60 * 1000; // 5 minutes

  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    
    if (!entry) return null;

    const isExpired = Date.now() - entry.timestamp > this.TTL;
    
    if (isExpired) {
      this.cache.delete(key);
      return null;
    }

    return entry.data;
  }

  set<T>(key: string, data: T): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }

  clear(): void {
    this.cache.clear();
  }
}
```

---

### Pattern 11: ShareReplay for Multiple Subscribers

**Use Case:** Avoiding duplicate HTTP calls for same data

**Pattern Name:** ShareReplay Pattern

```typescript
@Injectable({ providedIn: 'root' })
export class UserService {
  private readonly http = inject(HttpClient);
  private userCache$?: Observable<User>;

  getUser(id: number): Observable<User> {
    if (!this.userCache$) {
      this.userCache$ = this.http.get<User>(`/api/users/${id}`).pipe(
        shareReplay({ bufferSize: 1, refCount: true })
      );
    }
    return this.userCache$;
  }

  clearCache(): void {
    this.userCache$ = undefined;
  }
}

// Multiple components can subscribe without duplicate requests
@Component({})
export class Component1 {
  user$ = inject(UserService).getUser(1); // Makes HTTP request
}

@Component({})
export class Component2 {
  user$ = inject(UserService).getUser(1); // Reuses cached result
}
```

---

## üö® Error Handling Patterns

### Pattern 12: Centralized Error Handler

**Use Case:** Global error handling and logging

**Pattern Name:** Global Error Interceptor

```typescript
@Injectable()
export class ErrorInterceptor implements HttpInterceptor {
  private readonly notificationService = inject(NotificationService);

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    return next.handle(req).pipe(
      catchError((error: HttpErrorResponse) => {
        let errorMessage = 'An error occurred';

        if (error.error instanceof ErrorEvent) {
          // Client-side error
          errorMessage = `Error: ${error.error.message}`;
        } else {
          // Server-side error
          errorMessage = `Error Code: ${error.status}\nMessage: ${error.message}`;
        }

        this.notificationService.showError(errorMessage);
        
        return throwError(() => error);
      })
    );
  }
}

// Register in app.config.ts
export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(
      withInterceptors([ErrorInterceptor])
    )
  ]
};
```

---

### Pattern 13: Error State in Services

**Use Case:** Managing error state alongside data

**Pattern Name:** Error State Pattern

```typescript
@Injectable({ providedIn: 'root' })
export class DataService {
  private readonly _data = signal<Data[]>([]);
  private readonly _error = signal<string | null>(null);
  private readonly _loading = signal(false);

  readonly data = this._data.asReadonly();
  readonly error = this._error.asReadonly();
  readonly loading = this._loading.asReadonly();

  // Computed: Show error state in UI
  readonly hasError = computed(() => this._error() !== null);
  readonly errorMessage = computed(() => this._error() ?? '');

  loadData(): void {
    this._loading.set(true);
    this._error.set(null);

    this.http.get<Data[]>('/api/data').pipe(
      tap(data => {
        this._data.set(data);
        this._loading.set(false);
      }),
      catchError(err => {
        this._error.set(this.extractErrorMessage(err));
        this._loading.set(false);
        this._data.set([]);
        return of([]);
      })
    ).subscribe();
  }

  private extractErrorMessage(error: HttpErrorResponse): string {
    if (error.error?.message) {
      return error.error.message;
    }
    if (error.status === 0) {
      return 'Network error. Please check your connection.';
    }
    return `Server error: ${error.status}`;
  }

  clearError(): void {
    this._error.set(null);
  }
}
```

---

## ‚è≥ Loading State Patterns

### Pattern 14: Loading State with Minimum Duration

**Use Case:** Preventing loading spinner flicker

**Pattern Name:** Minimum Loading Duration Pattern

```typescript
@Injectable({ providedIn: 'root' })
export class DataService {
  private readonly MIN_LOADING_TIME = 300; // ms

  private readonly _loading = signal(false);
  readonly loading = this._loading.asReadonly();

  loadData(): void {
    const startTime = Date.now();
    this._loading.set(true);

    this.http.get('/api/data').pipe(
      switchMap(data => {
        const elapsed = Date.now() - startTime;
        const remainingTime = Math.max(0, this.MIN_LOADING_TIME - elapsed);
        
        // Ensure loading shows for minimum duration
        return timer(remainingTime).pipe(
          map(() => data)
        );
      }),
      tap(() => this._loading.set(false))
    ).subscribe();
  }
}
```

---

### Pattern 15: Loading State Per Request

**Use Case:** Managing multiple concurrent requests

**Pattern Name:** Request Tracking Pattern

```typescript
@Injectable({ providedIn: 'root' })
export class LoadingService {
  private readonly activeRequests = signal(0);
  
  readonly loading = computed(() => this.activeRequests() > 0);

  startRequest(): void {
    this.activeRequests.update(count => count + 1);
  }

  endRequest(): void {
    this.activeRequests.update(count => Math.max(0, count - 1));
  }
}

// HTTP Interceptor
@Injectable()
export class LoadingInterceptor implements HttpInterceptor {
  private readonly loadingService = inject(LoadingService);

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    this.loadingService.startRequest();

    return next.handle(req).pipe(
      finalize(() => this.loadingService.endRequest())
    );
  }
}
```

---

## üé® Additional Patterns

### Pattern 16: TrackBy for Performance

**Use Case:** Optimizing list rendering

**Pattern Name:** TrackBy Function Pattern

```typescript
@Component({
  template: `
    @for (item of items(); track trackById($index, item)) {
      <div>{{ item.name }}</div>
    }
  `
})
export class ListComponent {
  items = input.required<Item[]>();

  // TrackBy function prevents unnecessary re-renders
  trackById(index: number, item: Item): number {
    return item.id;
  }

  // For complex objects
  trackByComposite(index: number, item: Activity): string {
    return `${item.project}-${item.employee}-${item.date}`;
  }
}
```

---

### Pattern 17: Form State Management (Signal)

**Use Case:** Managing form state reactively

**Pattern Name:** Signal Form Pattern

```typescript
@Component({
  template: `
    <form (ngSubmit)="onSubmit()">
      <input 
        [value]="formData().email"
        (input)="updateEmail($event.target.value)"
      />
      <button 
        [disabled]="!isValid()"
        type="submit"
      >
        Submit
      </button>
    </form>
  `
})
export class FormComponent {
  private readonly _formData = signal({
    email: '',
    password: ''
  });

  readonly formData = this._formData.asReadonly();

  // Computed validation
  readonly isValid = computed(() => {
    const data = this._formData();
    return data.email.includes('@') && data.password.length >= 8;
  });

  updateEmail(email: string): void {
    this._formData.update(data => ({ ...data, email }));
  }

  onSubmit(): void {
    if (this.isValid()) {
      console.log('Submitting:', this._formData());
    }
  }
}
```

---

## üìä Pattern Comparison Table

| Pattern | Use Case | Zone.js | Signals | Complexity |
|---------|----------|---------|---------|------------|
| Signal State | Modern state management | ‚ùå | ‚úÖ | Low |
| Observable State | Traditional state | ‚úÖ | ‚ùå | Medium |
| Repository | API separation | Both | Both | Low |
| Facade | Simplify complex services | Both | Both | Medium |
| Smart/Dumb | Component separation | Both | Both | Low |
| Debounce | Reduce API calls | Both | Both | Medium |
| TTL Cache | Response caching | Both | Both | Medium |
| ShareReplay | Prevent duplicate calls | ‚úÖ | ‚ùå | Low |
| TrackBy | List performance | Both | Both | Low |

---

## üéØ Quick Decision Guide

**Choose Signals when:**
- ‚úÖ Building new Angular 17+ apps
- ‚úÖ Want zoneless applications
- ‚úÖ Need synchronous, predictable state
- ‚úÖ Want better performance

**Choose Observables when:**
- ‚úÖ Working with existing Zone.js apps
- ‚úÖ Need complex async operations
- ‚úÖ Heavy RxJS operator usage
- ‚úÖ Multiple async sources to combine

**Use Both when:**
- ‚úÖ Migrating from Zone.js to zoneless
- ‚úÖ Some features need RxJS power
- ‚úÖ Converting observables to signals with `toSignal()`

---

## üìù Notes

- All patterns are production-tested
- Patterns can be mixed and matched
- Choose based on your specific use case
- Consider team familiarity and project requirements
- Performance test in your specific context
